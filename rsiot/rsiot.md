#### 1. Эталонная модель взаимодействия открытых систем и стек TCP/IP.

>todo

#### 2. Серверы и серверное ПО.

>todo

#### 3. Стеки LAMP, MEAN и др.

>todo

#### 4. Противоречия между целями бизнеса и разработчиков. Поведение или архитектура.

>todo

#### 5. Три уровня архитектуры программной системы.

>todo

#### 6. Парадигмы программирования: структурное. Ограничения, выгода.

>todo

#### 7. Парадигмы программирования: объектно-ориентированное. Ограничения, выгода.

>todo

#### 8. Парадигмы программирования: функциональное. Ограничения, выгода.

>todo

#### 9. SOLID: принцип единственной ответственности (SRP), принцип открытости-закрытости (OCP).

**Принцип единственной ответственности (Single Responsibility Principle)**

Данный принцип гласит: **никогда не должно быть больше одной причины изменить класс.**

На каждый объект возлагается одна обязанность, полностью инкапсулированная в класс. Все сервисы класса направлены на обеспечение этой обязанности. 

Такие классы всегда будет просто изменять, если это понадобится, потому что понятно, за что класс отвечает, а за что — нет. То есть можно будет вносить изменения и не бояться последствий — влияния на другие объекты. А еще подобный код гораздо проще тестировать, ведь вы покрываете тестами одну функциональность в изоляции от всех остальных. Если класс имеет несколько назначений, его нужно разделить на отдельные классы.

**Принцип открытости-закрытости (Open Closed Principle)**

Этот принцип описывают так: **программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.** 

Это означает, что должна быть возможность изменять внешнее поведение класса, не внося физические изменения в сам класс. Следуя этому принципу, классы разрабатываются так, чтобы для подстройки класса к конкретным условиям применения было достаточно расширить его и переопределить некоторые функции. 

Поэтому система должна быть гибкой, с возможностью работы в переменных условиях без изменения исходного кода.

#### 10. SOLID: принцип подстановки Барбары Лисков (LSP), принцип разделения интерфейсов (ISP). 

**Принцип подстановки Барбары Лисков (Liskov’s Substitution Principle)**

Это вариация принципа открытости/закрытости. Его можно описать так: **объекты в программе можно заменить их наследниками без изменения свойств программы.** 

Это означает, что класс, разработанный путем расширения на основании базового класса, должен переопределять его методы так, чтобы не нарушалась функциональность с точки зрения клиента. То есть, если разработчик расширяет ваш класс и использует его в приложении, он не должен изменять ожидаемое поведение переопределенных методов. 

Подклассы должны переопределять методы базового класса так, чтобы не нарушалась функциональность с точки зрения клиента.

**Принцип разделения интерфейсов (Interface Segregation Principle)**

Характеризуется следующим утверждением: **клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.** 

Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более мелкие и специфические, чтобы клиенты мелких интерфейсов знали только о методах, необходимых в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

#### 11. SOLID: принцип инверсии зависимостей (DIP).

**Принцип инверсии зависимостей (Dependency Inversion Principle)**

Этот принцип SOLID описывают так: **зависимости внутри системы строятся на основе абстракций.**

Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. 

Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономными и соединялись друг с другом с помощью абстракции. Применяя этот принцип, одни модули можно легко заменять другими, всего лишь меняя модуль зависимости, и тогда никакие перемены в низкоуровневом модуле не повлияют на высокоуровневый.

#### 12. Принципы связности компонентов. Их противоречия.

>todo

#### 13. Принципы сочетаемости компонентов.

>todo

#### 14. Бизнес-логика и бизнес-правила.

>todo

#### 15. Горизонтальное и вертикальное разбиение приложения.

>todo

#### 16. Режимы разделения приложения.

>todo

#### 17. Границы. Пересечение границ.

>todo

#### 18. Большой Комок Грязи и концептуальные недостатки фреймворков.

>todo

#### 19. Трёхслойная архитектура М.Фаулера.

>todo

#### 20. Чистая архитектура Р.Мартина.

![xui](./clean_architecture.png)

Clean Architecture объединила в себе идеи нескольких других архитектурных подходов, которые сходятся в том, что архитектура должна:

- быть тестируемой;
- не зависеть от UI;
- не зависеть от БД, внешних фреймворков и библиотек.

Это достигается разделением на слои и следованием Dependency Rule (правилу зависимостей).

**Dependency Rule говорит, что внутренние слои не должны зависеть от внешних.** То есть наша бизнес-логика и логика приложения не должны зависеть от презентеров, UI, баз данных и т.п. На оригинальной схеме это правило изображено стрелками, указывающими внутрь.

_Имена сущностей (классов, функций, переменных, чего угодно), объявленных во внешних слоях, не должны встречаться в коде внутренних слоев._

Это правило позволяет строить системы, которые будет проще поддерживать, потому что изменения во внешних слоях не затронут внутренние слои.

Выделяют 4 слоя:
- **Entities.** Бизнес-логика общая для многих приложений.
- **Use Cases (Interactors).** Логика приложения.
- **Interface Adapters.** Адаптеры между Use Cases и внешним миром. Сюда попадают Presenter’ы из MVP, а также Gateways (репозитории). Преобразовывают данные от use case в формат для внешних агентов и систем хранения (БД, веб, GUI)
- **Frameworks.** Самый внешний слой, тут лежит все остальное: UI, база данных, http-клиент, и т.п.

**Переходы между слоями осуществляются через Boundaries**, то есть через два интерфейса: один для запроса и один для ответа. Они нужны, чтобы внутренний слой не зависел от внешнего (следуя Dependency Rule), но при этом мог передать ему данные.

Через границы данные передаются в скалярном виде или простейшими структурами и объектами – Data Transfer Objects (DTO).

#### 21. Порты и Адаптеры А.Кокберна. Уровни гексагональной архитектуры.

*Презентация ПРиС 05, слайды 9-11; метода к 4-ой лабе*

**Гексагональная архитектура (Порты и Адаптеры)**

Гексагональная архитектура (в отличие от трехслойной) – симметрично трактует внешние связи. Вместо уровня представления – входящие адаптеры, вместо систем хранения – исходящие адаптеры.

В центре – бизнес-логика, которая не зависит от адаптеров. У бизнес-логики есть порты, определяющие как взаимодействовать с внешним кодом (интерфейсы).

Адаптеры реализуют порты.

![ports and adapters](./21/ports_and_adapters.png)

**Уровни гексагональной архитектуры**

* Бизнес-логика реализуется уровнями домена (критические бизнес-правила) и приложения (варианты использования)
* Инфраструктура содержит адаптеры для взаимодействия с внешним миром
* Dependency Rule: все зависимости только внутрь

+: Независимость разработки домена от деталей, тестируемость бизнес-логики

![hex levels](./21/hex_levels.png)

Пример:

![hex example](./21/hex_example.png)

Микросервисная архитектура - соединенные между собой шестиугольники.

*Вон Вернон. Реализация методов предметно-ориентированного проектирования. Стр. 183-187*

**ГЕКСАГОНАЛЬНОЙ АРХИТЕКТУРОЙ (или Порты и Адаптеры)** Элистер Кокберн назвал стиль, предназначенный для создания симметрии. Она достигает этой цели, разрешая множеству разнообразных клиентов взаимодействовать с системой на равной основе. Нужен новый клиент? Не проблема. Просто добавьте АДАПТЕР для преобразования любой входной информации клиента в данные, понятные для внутреннего интерфейса прикладного программирования. В то же время механизмы вывода, развернутые в системе, такие как средства графической визуализации, постоянного хранения данных и передачи сообщений, могут быть разнообразными и взаимозаменяемыми. Это возможно благодаря АДАПТЕРУ, созданному для преобразования результатов работы приложения в форму, приемлемую для конкретного механизма вывода.

Обычно место, в котором клиенты взаимодействуют с системой, называют "внешним интерфейсом" ("front end"). Аналогично место, откуда приложение извлекает постоянно хранящиеся данные, где оно сохраняет постоянно хранящиеся данные или пересылает выходную информацию, называется "внутренним интерфейсом" ("bасk end"). Однако гексагональная архитектура вводит другую классификацию частей системы, как показано на рис. 4.4. Существуют две основные области внешняя и внутренняя. Внешняя область позволяет разнообразным клиентам вводить данные и предоставляет механизмы для извлечения постоянно хранящихся данных, сохранять результаты работы приложения (например, в базе данных) или посылать их куда-нибудь (например, посылать сообщения).

![img 4.4](./21/img4_4.png)

Строгого определения, что такое ПОРТ, не существует и это обеспечивает гибкость концепции. Независимо от разновидности ПОРТА, на него поступают запросы клиента, а АДАПТЕР преобразовывает их входную информацию. Затем он вызывает операцию приложения или посылает приложению событие. Тем самым управление передается во внутреннюю часть системы.

Приложение получает запросы с помощью своего открытого интерфейса API. Границы приложения, или внутренний шестиугольник, также представляют собой границу сценария использования (или пользовательские истории). Иначе говоря, мы должны создавать сценарии использования, основываясь на функциональных требованиях приложения, а не на требованиях многочисленных и разнообразных клиентов или механизмов вывода. Когда приложение получает запрос через свой интерфейс API, оно использует модель предметной области для выполнения всех запросов, связанных с реализацией бизнес-логики. Таким образом, интерфейс API приложения публикуется как множество СЛУЖБ ПРИЛОЖЕНИЯ.

Большое преимущество ГЕКСАГОНАЛЬНОЙ АРХИТЕКТУРЫ заключается в том, что АДАПТЕРЫ легко поддаются тестированию. Все приложение и модель предметной области можно разрабатывать и тестировать до того, как появятся клиенты и механизмы хранения данных, до принятия каких-либо решений о поддержке протоколов HTTP/REST, SOAP или ПОРТОВ, рассылающих сообщения. Любое количество тестовых клиентов можно создать еще до того, как будет завершен макет пользовательского интерфейса. Задолго до того как будет выбран механизм постоянного хранения данных, в памяти можно развернуть ХРАНИЛИЩА для имитации постоянного хранения во время тестирования. Так, можно достичь значительного прогресса в разработке ядра независимо от вспомогательных технических компонентов.

При правильном проектировании внутренний шестиугольник - приложение и модель предметной области - никак не повлияет на внешние части. Это создаст четкие границы, внутри которых будет реализован каждый сценарий использования. Помимо произвольного количества клиентов, АДАПТЕР может поддерживать многочисленные автоматизированные тесты и реальные клиенты, а также механизмы хранения, рассылки сообщений и другие средства вывода.

#### 22. Правило зависимостей и инверсия зависимостей в гексагональной архитектуре.

>todo

#### 23. Типовые решения организации бизнес-логики: сценарий транзакции.

>todo

#### 24. Типовые решения организации бизнес-логики: модель предметной области.

>todo

#### 25. Типовые решения организации бизнес-логики: модуль таблицы.

>todo

#### 26. Слой служб.

>todo

#### 27. Предметно-ориентированное проектирование. Определение, цели, задачи.

>todo

#### 28. Стратегическое проектирование DDD. Концепции.

Domain-Driven Design (Предметно-ориентированное проектирование) - это набор принципов и схем, направленных на создание оптимальных систем объектов.

DDD сводится к созданию программных абстракций, которые называются моделями предметных областей.
В эти модели входит бизнес-логика, устанавливающая связь между реальными условиями области применения продукта и кодом.
Предметно-ориентированное проектирование не является какой-либо конкретной технологией или методологией. DDD — это набор правил, которые позволяют принимать правильные проектные решения. Данный подход позволяет значительно ускорить процесс проектирования программного обеспечения в незнакомой предметной области.

Основная цель DDD: моделировать сложную предметную область так, чтобы программная реализация была простой в случае если:
- Если приложение будет значительно расти и усложняться
- Если предметная область сложна и/или незнакома

DDD основано на:
- Стратегическое проектирование - моделирование предметной области, с разбиением на подобласти, с точки зрения бизнеса, но не технических аспектов,
позволяет поднять уровень знаний (в предметной области) разработчиков и значительно упростить последующую реализацию.
- Тактическое проектирование - применение паттернов и инструментальных средств для моделирования конкретных объектов и их взаимосвязей в рамках
подобластей предметной области.

Концепции DDD:
- Эксперты предметной области - люди, полностью понимающие предметную область бизнеса, для которого строится приложени.
- Модель предметной области - объектная модель предметной области, включающая в себя как поведение, так и данные.
- Подобласти - часть предметной области, отдельная логическая модель некоторой предметной области.
- Единый язык - модель, именованная в терминах предметной области, в четко определенном ограниченном контексте.
- Ограниченный контекст - семантическая контекстная граница; область, в которой реализуется модель.
- Смысловое ядро - ограниченный контекст, который разрабатывается как ключевая стратегическая инциатива; самая важная модель, приносящая конкурентное преимущество.
- Связывание контекстов - это взаимодействие смыслового ядра с другими ограниченными контекстами, любых ограниченных контекстов между собой.
- Карты контекстов - совокупность ограниченных контекстов, а также интеграционных связей между ними.

#### 29. Единый язык и ограниченные контексты.

Единый язык - модель (понятия, объекты, взаимосвязи, процессы), именованная в терминах предметной области, в четко определенном ограниченном контексте.
Это один из основных и самых важных шаблонов предметного-ориентированного проектирования. Это настоящий язык, созданный целостной командой – экспертами в предметной области, разработчиками, бизнес-аналитиками и всеми, кто вовлечен в создание системы. Роль в команде не столь существенна, поскольку каждый член команды использует для описания проекта единый язык. Процесс создания единого языка более творческий чем формальный, так как он, как и любой другой естественный язык, постоянно развивается, а те артефакты, которые вначале способствовали разработке полезного единого языка, со временем устаревают. В итоге, остаются только самые устойчивые и проверенные элементы.
Порой, в нашей профессии, сформулировать требование к продукту бывает сложнее, чем реализовать его. Разные предметные области сложны по своему. Разрабатывая приложения для банка, трейдинга и др. можно столкнутся с кучей непонятных понятий. 
Единый язык — это базовая концепция борьбы со сложностью. Если предметная область итак требует изучения, то не стоит делать вещи еще сложнее и заставлять людей разбираться еще и в вашей модели предметной области. Стоит называть вещи одинаково как в спецификации, так и в коде.

Ограниченный контекст – семантическая контекстная граница; область, в которой реализуется модель. Очень важно понимать, что в рамках предметной области смысл определенного термина или фразы может сильно отличаться. Ограниченный контекст - граница, в пределах которой понятия единого языка имеют вполне конкретное контекстное значение.
В каждом ограниченном контексте существует только один единый язык.
- Ограниченные контексты являются относительно небольшими, меньше чем может показаться на первый взгляд. 
- Ограниченный контекст достаточно велик только для единого языка изолированной предметной области, но не больше.
- Единый значит «вездесущий» или «повсеместный», т. е. язык, на котором говорят члены команды и на котором выражается отдельная модель предметной области, которую разрабатывает команда. 
- Язык является единым только в рамках команды, работающей над проектом в едином ограниченном контексте.
- Попытка применить единый язык в рамках всего предприятия или что хуже, среди нескольких предприятий, закончится провалом.

#### 30. Подобласти. Смысловое ядро.

Подобласть - часть предметной области, отдельная логическая модель некоторой предметной области. Подобласти позволяют быстрее определить разные части предметной области, необходимые для решения конкретной задачи.

Подобласти делятся на 3 типа:
- Смысловое ядро - это подобласть, имеющая первостепенное значение для организации. Со стратегической точки зрения бизнес должен выделяться своим смысловым ядром. Большинство DDD проектов сосредоточены именно на смысловом ядре. Лучшие разработчики и эксперты должны быть задействованы именно в этой подобласти. Большинство инвестиций должны быть направлены именно сюда для достижения преимущества для бизнеса и получения наибольшей прибыли. Эта задача имеет очень высокий приоритет для организации, потому что именно ее решение дает конкурентное преимущество.
- Вспомогательная подобласть - такая подобласть требует специального моделирования ситуаций, для которых не существует готовых решений. Однако такие подобласти не требуют настолько больших инвестиций, как смысловое ядро. Разработку таких ограниченных контекстов можно поручить сторонним организациям, чтобы не перепутать их с областями стратегического назначения и не вложить в них слишком большие средства. Эта подобласть не является самой важной, может быть реализована позже. И все же это важные программные модели, потому что смысловое ядро не может успешно работать без них. 
- Универсальная подобласть -  Этот вид решения можно приобрести готовым, но можно также привлечь к его разработке сторонние организации или даже отдельное подразделение вашей организации, в которую не входят элитные разработчики, которые в основном должны заниматься смысловым ядром и в меньшей степени вспомогательными подобластями. Опасайтесь принять универсальную подобласть за смысловое ядро. Не надо вкладывать в нее крупные инвестиции.

#### 31. Способы связывания контекстов: общее ядро, партнёрство, клиент-поставщик.

>todo

#### 32. Способы связывания контекстов: конформист, предохранительный уровень, службы с открытым протоколом.

>todo

#### 33. Способы связывания контекстов: общедоступный язык, отдельное существование.

>todo

#### 34. Технологические нюансы связывания контекстов.

>todo

#### 35. Сущность. Объект значений. Фабрика. 

>todo

#### 36. Сервисы доменные, прикладные, инфраструктурные.

>todo

#### 37. Агрегат. Генерация идентичности. Репозиторий. 

>todo

#### 38. Правила агрегатов. Свойства агрегатов.

>todo

#### 39. Доменные события. Надёжность публикации.

>todo

#### 40. Сага. Компенсирующие транзакции.

>todo

#### 41. Хореография и оркестрация саги.

>todo

#### 42. Порождение событий (ES).

>todo

#### 43. Чем плох монолит?

>todo

#### 44. Куб масштабирования систем.

>todo

#### 45. Сервис-ориентированная архитектура и микросервисы.

>todo

#### 46. Достоинства и недостатки микросервисов.

>todo

#### 47. Функциональная декомпозиция на сервисы.

>todo

#### 48. Команды и сервисы: размер, состав и закон Конвея.

>todo

#### 49. Проблемы и выгоды распределённости в микросервисной архитектуре.

>todo

#### 50. Стили взаимодействия микросервисов.

>todo

#### 51. Удалённый вызов процедур: REST.

>todo

#### 52. Удалённый вызов процедур: gRPC.

>todo

#### 53. Удалённый вызов процедур: механизм сообщений.

>todo

#### 54. Проблемы запроса данных из нескольких сервисов. Объединение API.

>todo

#### 55. CQRS. Запрашивающий сервис.

>todo

#### 56. Процесс и стратегии перехода от монолита к микросервисам.

>todo

#### 57. Определение и история DevOps. Концепции разработки, релиза и развертывания ПО. 

>todo

#### 58. Непрерывная сборка и развертывание. Конвейер непрерывного развертывания: автоматизация сборки, тестирование, развертывание, эксплуатация.

>todo

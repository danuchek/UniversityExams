#### 1. Эталонная модель взаимодействия открытых систем и стек TCP/IP.

>todo

#### 2. Серверы и серверное ПО.

>todo

#### 3. Стеки LAMP, MEAN и др.

>todo

#### 4. Противоречия между целями бизнеса и разработчиков. Поведение или архитектура.

>todo

#### 5. Три уровня архитектуры программной системы.

>todo

#### 6. Парадигмы программирования: структурное. Ограничения, выгода.

>todo

#### 7. Парадигмы программирования: объектно-ориентированное. Ограничения, выгода.

>todo

#### 8. Парадигмы программирования: функциональное. Ограничения, выгода.

>todo

#### 9. SOLID: принцип единственной ответственности (SRP), принцип открытости-закрытости (OCP).

**Принцип единственной ответственности (Single Responsibility Principle)**

Данный принцип гласит: **никогда не должно быть больше одной причины изменить класс.**

На каждый объект возлагается одна обязанность, полностью инкапсулированная в класс. Все сервисы класса направлены на обеспечение этой обязанности. 

Такие классы всегда будет просто изменять, если это понадобится, потому что понятно, за что класс отвечает, а за что — нет. То есть можно будет вносить изменения и не бояться последствий — влияния на другие объекты. А еще подобный код гораздо проще тестировать, ведь вы покрываете тестами одну функциональность в изоляции от всех остальных. Если класс имеет несколько назначений, его нужно разделить на отдельные классы.

**Принцип открытости-закрытости (Open Closed Principle)**

Этот принцип описывают так: **программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.** 

Это означает, что должна быть возможность изменять внешнее поведение класса, не внося физические изменения в сам класс. Следуя этому принципу, классы разрабатываются так, чтобы для подстройки класса к конкретным условиям применения было достаточно расширить его и переопределить некоторые функции. 

Поэтому система должна быть гибкой, с возможностью работы в переменных условиях без изменения исходного кода.

#### 10. SOLID: принцип подстановки Барбары Лисков (LSP), принцип разделения интерфейсов (ISP). 

**Принцип подстановки Барбары Лисков (Liskov’s Substitution Principle)**

Это вариация принципа открытости/закрытости. Его можно описать так: **объекты в программе можно заменить их наследниками без изменения свойств программы.** 

Это означает, что класс, разработанный путем расширения на основании базового класса, должен переопределять его методы так, чтобы не нарушалась функциональность с точки зрения клиента. То есть, если разработчик расширяет ваш класс и использует его в приложении, он не должен изменять ожидаемое поведение переопределенных методов. 

Подклассы должны переопределять методы базового класса так, чтобы не нарушалась функциональность с точки зрения клиента.

**Принцип разделения интерфейсов (Interface Segregation Principle)**

Характеризуется следующим утверждением: **клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.** 

Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более мелкие и специфические, чтобы клиенты мелких интерфейсов знали только о методах, необходимых в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

#### 11. SOLID: принцип инверсии зависимостей (DIP).

**Принцип инверсии зависимостей (Dependency Inversion Principle)**

Этот принцип SOLID описывают так: **зависимости внутри системы строятся на основе абстракций.**

Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. 

Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономными и соединялись друг с другом с помощью абстракции. Применяя этот принцип, одни модули можно легко заменять другими, всего лишь меняя модуль зависимости, и тогда никакие перемены в низкоуровневом модуле не повлияют на высокоуровневый.

#### 12. Принципы связности компонентов. Их противоречия.

>todo

#### 13. Принципы сочетаемости компонентов.

>todo

#### 14. Бизнес-логика и бизнес-правила.

>todo

#### 15. Горизонтальное и вертикальное разбиение приложения.

>todo

#### 16. Режимы разделения приложения.

>todo

#### 17. Границы. Пересечение границ.

>todo

#### 18. Большой Комок Грязи и концептуальные недостатки фреймворков.

>todo

#### 19. Трёхслойная архитектура М.Фаулера.

>todo

#### 20. Чистая архитектура Р.Мартина.

![xui](./clean_architecture.png)

Clean Architecture объединила в себе идеи нескольких других архитектурных подходов, которые сходятся в том, что архитектура должна:

- быть тестируемой;
- не зависеть от UI;
- не зависеть от БД, внешних фреймворков и библиотек.

Это достигается разделением на слои и следованием Dependency Rule (правилу зависимостей).

**Dependency Rule говорит, что внутренние слои не должны зависеть от внешних.** То есть наша бизнес-логика и логика приложения не должны зависеть от презентеров, UI, баз данных и т.п. На оригинальной схеме это правило изображено стрелками, указывающими внутрь.

_Имена сущностей (классов, функций, переменных, чего угодно), объявленных во внешних слоях, не должны встречаться в коде внутренних слоев._

Это правило позволяет строить системы, которые будет проще поддерживать, потому что изменения во внешних слоях не затронут внутренние слои.

Выделяют 4 слоя:
- **Entities.** Бизнес-логика общая для многих приложений.
- **Use Cases (Interactors).** Логика приложения.
- **Interface Adapters.** Адаптеры между Use Cases и внешним миром. Сюда попадают Presenter’ы из MVP, а также Gateways (репозитории). Преобразовывают данные от use case в формат для внешних агентов и систем хранения (БД, веб, GUI)
- **Frameworks.** Самый внешний слой, тут лежит все остальное: UI, база данных, http-клиент, и т.п.

**Переходы между слоями осуществляются через Boundaries**, то есть через два интерфейса: один для запроса и один для ответа. Они нужны, чтобы внутренний слой не зависел от внешнего (следуя Dependency Rule), но при этом мог передать ему данные.

Через границы данные передаются в скалярном виде или простейшими структурами и объектами – Data Transfer Objects (DTO).

#### 21. Порты и Адаптеры А.Кокберна. Уровни гексагональной архитектуры.

>todo

#### 22. Правило зависимостей и инверсия зависимостей в гексагональной архитектуре.

>todo

#### 23. Типовые решения организации бизнес-логики: сценарий транзакции.

>todo

#### 24. Типовые решения организации бизнес-логики: модель предметной области.

>todo

#### 25. Типовые решения организации бизнес-логики: модуль таблицы.

>todo

#### 26. Слой служб.

>todo

#### 27. Предметно-ориентированное проектирование. Определение, цели, задачи.

>todo

#### 28. Стратегическое проектирование DDD. Концепции.

>todo

#### 29. Единый язык и ограниченные контексты.

>todo

#### 30. Подобласти. Смысловое ядро.

>todo

#### 31. Способы связывания контекстов: общее ядро, партнёрство, клиент-поставщик.

>todo

#### 32. Способы связывания контекстов: конформист, предохранительный уровень, службы с открытым протоколом.

>todo

#### 33. Способы связывания контекстов: общедоступный язык, отдельное существование.

>todo

#### 34. Технологические нюансы связывания контекстов.

>todo

#### 35. Сущность. Объект значений. Фабрика. 

**Сущность** — объект, обладающий устойчивой идентичностью. Две сущности, чьи атрибуты имеют одинаковые значения, — это все равно разные объекты.

**Объект значений** — объект, представляющий собой набор значений. Два объекта значений с одинаковыми атрибутами взаимозаменяемы. Примером таких объектов может служить класс Money, который состоит из валюты и суммы.

**Фабрика** — объект или метод, реализующий логику создания объектов, которую ввиду ее сложности не следует размещать прямо в конструкторе. Фабрика также может скрывать конкретные классы, экземпляры которых создает. Она реализуется в виде статического метода или класса.

#### 36. Сервисы доменные, прикладные, инфраструктурные.

**Сервисы приложения** оперируют скалярными типами, трансформируя их в типы предметной области. Скалярными являются любые типы, неизвестные Доменной модели. Сюда включаются примитивные типы, и типы, не относящиеся к домену.

**Доменные сервисы** оперируют только типами, принадлежащими домену. Они содержат значимые концепции, которые могут быть найдены в Едином языке. Реализуют операции, которые недостаточно хорошо подходят сущностям или объектам значений.

**Инфраструктурные сервисы** реализуют все операции, которые касаются инфраструктуры, такие как отправка почты или журналирование значимых данных. В терминах гексагональной архитектуры, они лежат вне границ домена.

#### 37. Агрегат. Генерация идентичности. Репозиторий. 

**Агрегат** — это кластер доменных объектов, с которыми можно обращаться как с единым целым. Он состоит из корневой сущности и иногда одной или нескольких сущностей и объектов значений.

Агрегаты разбивают доменную модель на блоки, в которых легче разобраться по отдельности. Они также проясняют область применения операций, таких как загрузка, обновление и удаление. Эти операции распространяются на весь агрегат, а не на какие-то его части.

В классических подходах для **генерации идентификатора сущностей** часто полагаются на механизм хранения – базу данных. Например, на поле с атрибутом `AUTO_INCREMENT` в БД MySQL.

Среди других подходов можно выделить генерацию идентификатора клиентом, суррогатную идентичность и пр. Мы же будем рассматривать следующий подход: идентификатор корня агрегата генерируется приложением, реализацией специального метода репозитория. Это позволит в зависимости от реализации данного репозитория на инфраструктурном уровне релизовать как генерацию в БД MySQL, так и, например, генерацию UUID, или фейковых идентификаторов для тестирования.

Идентификатор, единожды сгенерированный, является неизменным. Для максимальной степени обеспечения данного правила идентификаторы представляются не простыми свойствами ординарного типа, которые могут быть просто изменены, а объектами значений.

**Репозиторий** — объект, предоставляющий доступ к постоянным сущностям и инкапсулирующий механизм доступа к базе данных. Репозиторий служит посредником между доменом и слоем данных используя интерфейс, схожий с коллекцией, для доступа к доменным объектам.

#### 38. Правила агрегатов. Свойства агрегатов.

Правила агрегатов:

1. **Ссылайтесь только на корень агрегата.**
Первое правило требует, чтобы корневая сущность была единственной частью агрегата, на которую могут ссылаться внешние классы. Для обновления агрегата клиенту необходимо вызвать метод из его корня. Например, сервис использует репозиторий, чтобы загрузить агрегат из базы данных и получить ссылку на его корень. С помощью метода, вызываемого из корня, он обновляет агрегат. Это правило гарантирует, что агрегат способен обеспечивать соблюдение своих инвариантов.

2. **Межагрегатные ссылки должны применять первичные ключи.**
Правило состоит в том, что агрегаты ссылаются друг на друга по уникальному значению, например по первичному ключу, а не по объектным ссылкам. Отказ от объектных ссылок в пользу уникальных идентификаторов означает, что агрегаты слабо связаны между собой. Это позволяет четко определить границы между ними и избежать случайного обновления не того агрегата. К тому же нам не нужно беспокоиться об объектных ссылках, которые выходят за пределы одного сервиса.

3. **Одна транзакция создает или обновляет один агрегат.**
Это правило идеально подходит для микросервисной архитектуры. Оно гарантирует, что транзакция не выйдет за пределы сервиса. А также хорошо согласуется с ограниченной транзакционной моделью большинства баз данных NoSQL. Это правило усложняет реализацию операций, которым нужно создавать или обновлять несколько агрегатов. Но это явно одна из тех проблем, для решения которых предназначены повествования (саги). Каждый этап повествования создает или обновляет ровно один агрегат.

Свойства агрегатов:

> Я не знаю то это или нет. Другой информации по теме я не нашёл 😔

<details>
    <summary>Один агрегат – один репозиторий</summary>
    За загрузку заказа и всех его строк отвечает репозиторий заказа.
</details>

<details>
    <summary>Чем меньше агрегат, тем удобнее работать и надежнее выполнение требований ACID-транзакционности</summary>
    В идеале одна сущность – один агрегат, а ссылки на другие сущности по id.
</details>

<details>
    <summary>Агрегаты строятся по бизнес-инвариантам</summary>
    Если есть use case, в котором нужно работать с внутренними сущностями агрегата – значит их вхождение в агрегат не является инвариантом, и они формируют отдельные агрегаты.
</details>

<details>
    <summary>Генерация идентификаторов сущностей</summary>
    Для корня агрегата – отвечает репозиторий. Для внутренних сущностей – сам агрегат.
</details>

#### 39. Доменные события. Надёжность публикации.

>todo

#### 40. Сага. Компенсирующие транзакции.

>todo

#### 41. Хореография и оркестрация саги.

>todo

#### 42. Порождение событий (ES).

>todo

#### 43. Чем плох монолит?

>todo

#### 44. Куб масштабирования систем.

>todo

#### 45. Сервис-ориентированная архитектура и микросервисы.

>todo

#### 46. Достоинства и недостатки микросервисов.

>todo

#### 47. Функциональная декомпозиция на сервисы.

>todo

#### 48. Команды и сервисы: размер, состав и закон Конвея.

>todo

#### 49. Проблемы и выгоды распределённости в микросервисной архитектуре.

>todo

#### 50. Стили взаимодействия микросервисов.

>todo

#### 51. Удалённый вызов процедур: REST.

>todo

#### 52. Удалённый вызов процедур: gRPC.

>todo

#### 53. Удалённый вызов процедур: механизм сообщений.

>todo

#### 54. Проблемы запроса данных из нескольких сервисов. Объединение API.

>todo

#### 55. CQRS. Запрашивающий сервис.

>todo

#### 56. Процесс и стратегии перехода от монолита к микросервисам.

>todo

#### 57. Определение и история DevOps. Концепции разработки, релиза и развертывания ПО. 

>todo

#### 58. Непрерывная сборка и развертывание. Конвейер непрерывного развертывания: автоматизация сборки, тестирование, развертывание, эксплуатация.

>todo

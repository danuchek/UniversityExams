#### 1. Эталонная модель взаимодействия открытых систем и стек TCP/IP.

>todo

#### 2. Серверы и серверное ПО.

>todo

#### 3. Стеки LAMP, MEAN и др.

>todo

#### 4. Противоречия между целями бизнеса и разработчиков. Поведение или архитектура.

>todo

#### 5. Три уровня архитектуры программной системы.

>todo

#### 6. Парадигмы программирования: структурное. Ограничения, выгода.

Сущность структурного подхода к разработке ИС заключается в ее декомпозиции (разбиении) на автоматизируемые функции: система разбивается на функциональные подсистемы, которые в свою очередь делятся на подфункции, подразделяемые на задачи и так далее.
Процесс разбиения продолжается вплоть до конкретных процедур. При этом автоматизируемая система сохраняет целостное представление, в котором все составляющие компоненты взаимоувязаны. При разработке системы "снизу-вверх" от отдельных задач ко всей системе целостность теряется, возникают проблемы при информационной стыковке отдельных компонентов.
Все наиболее распространенные методологии структурного подхода базируются на ряде общих принципов. В качестве двух базовых принципов используются следующие:
1. **принцип "разделяй и властвуй"** - принцип решения сложных проблем путем их разбиения на множество меньших независимых задач, легких для понимания и решения;
2. **принцип иерархического упорядочивания** - принцип организации составных частей проблемы в иерархические древовидные структуры с добавлением новых деталей на каждом уровне.

Выделение двух базовых принципов не означает, что остальные принципы являются второстепенными, поскольку игнорирование любого из них может привести к непредсказуемым последствиям (в том числе и к провалу всего проекта). Основными из этих принципов являются следующие:
1. **принцип абстрагирования** - заключается в выделении существенных аспектов системы и отвлечения от несущественных;
2. **принцип формализации** - заключается в необходимости строгого методического подхода к решению проблемы;
3. **принцип непротиворечивости** - заключается в обоснованности и согласованности элементов;
4. **принцип структурирования данных** - заключается в том, что данные должны быть структурированы и иерархически организованы.

**Преимущества:** 
- Легко распределять работу между программистами
- Естественные контрольные точки
- Легко выявлять ошибки
- Легко поддается тестированию (комплексное тестирование)
- Раннее начало процесса кодирования
- Снижается вероятность допустить логическую ошибку
- Упрощенное чтение кода

**Недостатки:**
- Отсутствие гибкости системы. После некоторого количества модификаций происходит смещение уровней абстракции, нарушается структура, что приводит к потере надежности (сопровождение затруднено и много стоит)
- Сложно изменить формы данных и структур

#### 7. Парадигмы программирования: объектно-ориентированное. Ограничения, выгода.

**Объектно-ориентированное программирование (ООП**) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.
К основным принципам ООП относятся:
1. **Полиморфизм** - способность функции одинаково обрабатывать данные разных типов.
2. **Инкапсуляция** – механизм позволяющий связывать данные и методы, работающие с этими данными, в единый объект и скрыть реализацию от пользователя.
3. **Абстракция** — это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе. Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи.
4. **Наследование** – принцип ООП, позволяющий описать новый класс на основе уже существующего (родительского), при этом свойства и функциональность родительского класса заимствуются новым классом.

**Преимущества ООП**:
- Легкая расширяемость
- Сокращение количества межмодульных вызовов и уменьшение объемов информации, передаваемой между модулями.
- Увеличивается показатель повторного использования кода.

**Недостатки ООП**:
- Резко увеличивается время на анализ и проектирование систем
- Увеличение времени выполнения
- Сложность распределения работ на начальном этапе

#### 8. Парадигмы программирования: функциональное. Ограничения, выгода.

**Функциональное программирование** — парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних. 
Основные принципы функционального программирования:
1. **Все функции — первого класса и высшего порядка**
	Для того, чтобы функция была первоклассной, у неё должна быть возможность быть объявленной в виде переменной. Это позволяет управлять функцией как обычным типом данных и в то же время исполнять её.
Функции высшего порядка же определяются как функции, принимающие другую функцию как аргумент или возвращающие функцию. Типичными примерами таких функций являются map и filter.
2. **Переменные неизменяемы**
	 В функциональном программировании вы не можете изменить переменную после её инициализации. Вы можете создавать новые, но не можете изменять существующие — и благодаря этому вы можете быть уверены, что никакая переменная не изменится.
3. **Все функции — чистые**
	Чистыми называют функции, которые не имеют побочных эффектов ввода-вывода и памяти (они зависят только от своих параметров и возвращают только свой результат)
4. **Ленивые вычисления**
	Ленивое вычисление подразумевает, что все значения инициализируются в момент обращения.
5. **Функциональное программирование основано на лямбда-исчислении.** 
	При вызове все функции проходят процесс каррирования. Он заключается в следующем: если вызывается функция с несколькими аргументами, то сперва она будет выполнена лишь с первым аргументом и вернёт новую функцию, содержащую на 1 аргумент меньше, которая будет немедленно вызвана. Этот процесс рекурсивен и продолжается до тех пор, пока не будут применены все аргументы, возвращая финальный результат. Поскольку функции являются чистыми, это работает.

**Преимущесвта ФП:**
- Возможности параллелизма (Поскольку отсутствие побочных эффектов гарантировано, в любом вызове функции всегда допустимо параллельное вычисление двух различных параметров — порядок их вычисления не может оказать влияния на результат вызова.)
- Повышение надёжности кода ( Любая функция работает только с локальными данными и работает с ними всегда одинаково, независимо от того, где, как и при каких обстоятельствах она вызывается. Невозможность мутации данных при пользовании ими в разных местах программы исключает появление труднообнаруживаемых ошибок)

**Недостатки ФП:**
- Требуется наличие высокоэффективного сборщика мусора. (Из-за отсутствия присваиваний появляется необходимость постоянного выделения и освобождения памяти)
- Так же необходимо наличие больших вычислительных мощностей ( Из-за особенностей работы лямбда-исчислений происходит множественный вызов функций, что замедляет выполнения программы) 

#### 9. SOLID: принцип единственной ответственности (SRP), принцип открытости-закрытости (OCP).

**Принцип единственной ответственности (Single Responsibility Principle)**

Данный принцип гласит: **никогда не должно быть больше одной причины изменить класс.**

На каждый объект возлагается одна обязанность, полностью инкапсулированная в класс. Все сервисы класса направлены на обеспечение этой обязанности. 

Такие классы всегда будет просто изменять, если это понадобится, потому что понятно, за что класс отвечает, а за что — нет. То есть можно будет вносить изменения и не бояться последствий — влияния на другие объекты. А еще подобный код гораздо проще тестировать, ведь вы покрываете тестами одну функциональность в изоляции от всех остальных. Если класс имеет несколько назначений, его нужно разделить на отдельные классы.

**Принцип открытости-закрытости (Open Closed Principle)**

Этот принцип описывают так: **программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.** 

Это означает, что должна быть возможность изменять внешнее поведение класса, не внося физические изменения в сам класс. Следуя этому принципу, классы разрабатываются так, чтобы для подстройки класса к конкретным условиям применения было достаточно расширить его и переопределить некоторые функции. 

Поэтому система должна быть гибкой, с возможностью работы в переменных условиях без изменения исходного кода.

#### 10. SOLID: принцип подстановки Барбары Лисков (LSP), принцип разделения интерфейсов (ISP).

**Принцип подстановки Барбары Лисков (Liskov’s Substitution Principle)**

Это вариация принципа открытости/закрытости. Его можно описать так: **объекты в программе можно заменить их наследниками без изменения свойств программы.** 

Это означает, что класс, разработанный путем расширения на основании базового класса, должен переопределять его методы так, чтобы не нарушалась функциональность с точки зрения клиента. То есть, если разработчик расширяет ваш класс и использует его в приложении, он не должен изменять ожидаемое поведение переопределенных методов. 

Подклассы должны переопределять методы базового класса так, чтобы не нарушалась функциональность с точки зрения клиента.

**Принцип разделения интерфейсов (Interface Segregation Principle)**

Характеризуется следующим утверждением: **клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.** 

Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более мелкие и специфические, чтобы клиенты мелких интерфейсов знали только о методах, необходимых в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

#### 11. SOLID: принцип инверсии зависимостей (DIP).

**Принцип инверсии зависимостей (Dependency Inversion Principle)**

Этот принцип SOLID описывают так: **зависимости внутри системы строятся на основе абстракций.**

Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. 

Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономными и соединялись друг с другом с помощью абстракции. Применяя этот принцип, одни модули можно легко заменять другими, всего лишь меняя модуль зависимости, и тогда никакие перемены в низкоуровневом модуле не повлияют на высокоуровневый.

#### 12. Принципы связности компонентов. Их противоречия.

**Компоненты** — это единицы развертывания. Они представляют наименьшие сущности, которые можно развертывать в составе системы.Компоненты используются повторно, разрабатываются и развертываются независимо друг от друга.

Принципы связности компонентов:

- **REP: Reuse/Release Equivalence Principle — принцип эквивалентности повторного использования и релиза;**

Все классы и модули, составляющие компонент, выпускаются вместе, получают номер версии и общую документацию.

- **CCP: Common Closure Principle — принцип согласованного изменения;**

Собирайте вместе все, что изменяется по одной причине и в одно время. Разделяйте все, что изменяется в разное время и по разным причинам.

Это принцип единственной ответственности (SRP), перефразированный для компонентов. Так же, как принцип SRP, гласящий, что класс не должен иметь нескольких причин для изменения, CCP требует, чтобы компонент не имел нескольких причин для изменения.

Этот принцип так же тесно связан с принципом открытости/закрытости (Open Closed Principle; OCP). CCP развивает его идею, предписывая объединять в один компонент только классы, закрытые для одного и того же вида изменений. То есть увеличивает вероятность, что изменение требований повлечет необходимость изменения минимального количества компонентов.

Для большинства приложений простота сопровождения важнее возможности повторного использования. Если возникнет необходимость изменить код приложения, предпочтительнее, если все изменения будут сосредоточены в одном месте, а не разбросаны по нескольким компонентам. Если изменения ограничиваются единственным компонентом, нам потребуется развернуть только один, изменившийся компонент. Другие компоненты, не зависящие от измененного, не придется повторно проверять и развертывать.

- **CRP: Common Reuse Principle — принцип совместного повторного использования.**

Принцип CRP указывает, что классы, имеющие множественные зависимости друг от друга, должны включаться в один компонент. Классы, не имеющие тесной связи, не должны быть в одном компоненте.

Но принцип CRP говорит не только о том, какие классы должны включаться в компонент; он также сообщает, какие классы не должны объединяться: 

Когда один компонент использует другой компонент, между ними образуется зависимость. Использующий компонент может нуждаться только в одном классе из используемого компонента, но это не ослабляет зависимости. Из-за этой зависимости изменение используемого компонента часто влечет необходимость соответствующих изменений в использующем компоненте. Даже если в использующем компоненте ничего не нужно изменять, его почти наверняка потребуется повторно скомпилировать, протестировать и развернуть. То есть когда образуется зависимость от компонента, желательно, чтобы она распространялась на все классы в этом компоненте.

Иначе говоря, классы, включаемые в компонент, должны быть неотделимы друг от друга — чтобы нельзя было зависеть от одних и не зависеть от других. Иначе нам придется повторно развертывать больше компонентов, чем требуется, и тратить существенно больше усилий.

CRP является обобщенной версией принципа разделения интерфейсов (ISP). Обобщая, эти принципы можно объединить в один: Не создавайте зависимостей от чего-либо неиспользуемого.

**Противоречия принципов связности**

![contradictions](https://rutlib5.com/books/32405/OEBPS/63530.png)

Принципы эквивалентности повторного использования (REP) и согласованного изменения (CCP) являются включительными: оба стремятся сделать компоненты как можно крупнее. Принцип повторного использования (CRP) — исключительный, стремящийся сделать компоненты как можно мельче. 

В начале разработки наибольшую важность имеет правая сторона треугольника, когда единственной жертвой является повторное использование. Но по мере развития и интеграции в другие проекты фокус начинает смещаться влево. То есть организация компонентов в проекте может изменяться с течением времени. Это больше связано с тем, как проект разрабатывается и используется, нежели с тем, что фактически этот проект делает.

#### 13. Принципы сочетаемости компонентов.

Следующие три принципа определяют правила взаимоотношений между компонентами. Это сново ведет к противоречиям между удобством разработки и логической организацией. 

- **Принцип ацикличности зависимостей**

Циклы в графе зависимостей компонентов недопустимы.

Проблема: одни и те же файлы с исходным кодом правят сразу несколько разработчиков -> Команда не в состоянии собрать стабильную версию проекта. Вместо этого разработчики правят и правят свой код, пытаясь заставить его работать с изменениями, сделанными кем-то другим.

Решение: разделении проекта на компоненты, которые могут выпускаться независимо. Компоненты становятся единицами работы, ответственность за которые можно возложить на одного разработчика или на небольшую группу. 

Когда разработчики добиваются работоспособности компонента, они выпускают новую версию для использования другими разработчиками. Когда появляется новая версия компонента, другие команды могут выбирать — сразу же задействовать новую версию или подождать. В результате ни одна команда не отдается на милость другим. Изменения в одном компоненте не оказывают немедленного влияния на другие команды. Каждая команда сама решает, когда начать адаптацию своего компонента для использования новой версии другого компонента. Кроме того, интеграция происходит небольшими шагами. Нет единого момента времени, когда все разработчики должны собраться вместе и интегрировать все, что они создали.

Однако чтобы добиться успеха, вы должны управлять структурой зависимостей компонентов. В ней не должно быть циклических зависимостей. Циклы приводят к значительному усложнению разработки и тестирования, определения порядка сборки компонентов.

Образовавшуюся циклическую зависимость всегда можно разорвать и привести граф зависимостей к форме ациклического ориентированного графа (DAG). Для этого используются два основных механизма:

1. Применить принцип инверсии зависимостей (Dependency Inversion Principle; DIP).
2. Создать новый компонент

Второе решение предполагает зависимость структуры компонентов от изменения требований. И действительно, с ростом приложения структура зависимостей компонентов растет и изменяется. Поэтому ее постоянно нужно проверять на предмет появления циклов. Когда образуются циклы, их нужно разрывать тем или иным способом. Иногда для этого приходится создавать новые компоненты, что заставляет разрастаться структуру зависимостей.

- Принцип устойчивых зависимостей

Зависимости должны быть направлены в сторону устойчивости.

Устойчивый компонент - компонент с множеством входящих зависимостей, потому что согласование изменений со всеми зависящими компонентами требует значительных усилий.

Компоненты, с большим трудом поддающиеся изменению (устойчивые компоненты), не должны зависеть от любых изменчивых компонентов. Иначе изменчивый компонент тоже трудно будет изменять. 

Не все компоненты должны быть устойчивыми. Если все компоненты в системе будут иметь максимальную устойчивость, такую систему невозможно будет изменить. Это нежелательная ситуация. В действительности структура компонентов должна проектироваться так, чтобы в ней имелись и устойчивые, и неустойчивые компоненты.

- Принцип устойчивости абстракций

Устойчивость компонента пропорциональна его абстрактности.

Принцип устойчивости абстракций (Stable Abstractions Principle; SAP) устанавливает связь между устойчивостью и абстрактностью. С одной стороны, он говорит, что устойчивый компонент также должен быть абстрактным, чтобы его устойчивость не препятствовала расширению, с другой — он говорит, что неустойчивый компонент должен быть конкретным, потому что неустойчивость позволяет легко изменять его код.

То есть стабильный компонент должен состоять из интерфейсов и абстрактных классов, чтобы его легко было расширять. Устойчивые компоненты, доступные для расширения, обладают достаточной гибкостью, чтобы не накладывать чрезмерные ограничения на архитектуру.

Принципы устойчивости абстракций (SAP) и устойчивых зависимостей (SDP) вместе соответствуют принципу инверсии зависимостей (DIP) для компонентов. Это верно, потому что принцип SDP требует, чтобы зависимости были направлены в сторону устойчивости, а принцип SAP утверждает, что устойчивость подразумевает абстрактность. То есть зависимости должны быть направлены в сторону абстрактности.


#### 14. Бизнес-логика и бизнес-правила.

>todo

#### 15. Горизонтальное и вертикальное разбиение приложения.

>todo

#### 16. Режимы разделения приложения.

>todo

#### 17. Границы. Пересечение границ.

>todo

#### 18. Большой Комок Грязи и концептуальные недостатки фреймворков.

**БОЛЬШОЙ КОМОК ГРЯЗИ** - беспорядочный, сырой, словно перемотанный на скорую руку изоляционной лентой и проводами, запутавшийся в джунглях спагетти-код. Мы все видели такой код. В этих системах легко найти признаки нерегулируемого роста и постоянных доделок. Информация распространяется без разбора между отдаленными элементами системы, при этом зачастую вся важная информация становится глобальной или дублируется. Структура системы в целом никогда не было точно определена. Если и была, то ее разрушили до такой степени, что оригинал уже не узнать. Программисты хоть немного понимающие архитектуру, обходят это болото стороной. И только те, кого она волнует мало и, возможно, те, кому нравится латать дыры в системе каждый день, довольны работой таких систем.

Почему система превращается в БОЛЬШОЙ КОМОК ГРЯЗИ? Иногда большие и страшные системы появляются из-за создания разового кода. **Разовый код** – это быстрый, черновой вариант кода, который должен был использоваться только один раз, а затем выброшен. Однако иногда такой код начинает жить собственной жизнью, несмотря на свою не проработанную структуру и плохо разработанную документацию или ее отсутствие. Он работает, зачем что-то чинить? Когда возникает какая-то проблема, то самый быстрый способ решить ее — изменить работающий код. Это избавляет от необходимости создавать программу с нуля, но со временем, простые разовые программы порождают БОЛЬШОЙ КОМОК ГРЯЗИ.

Даже системы с хорошо прописанной архитектурой рискуют пострадать от распада структуры. Любая успешная система находится под огнём постоянно изменяющихся требований, что постепенно подрывает ее структуру. Некогда чистые системы зарастают из-за поэтапного роста структуры, и элементы системы начинают разрастаться бесконтрольно.
Если не прекратить этот рост, то структура системы нарушается до такой степени, что от нее нужно отказываться.

Так как понимание системы становится все труднее, ее поддержка становится сложнее и обходится все дороже. Хорошие программисты отказываются работать с такой структурой. Один из способов остановить энтропию в ПО — перепроектирование (рефракторинг). Приверженность периодическому рефакторингу может защитить систему от сползания в БОЛЬШОЙ КОМОК ГРЯЗИ. В более серьезных случаях, трудно найти альтернативу, поэтому все сносят и начинают строительство заново.

**Концептуальные недостатки фреймворков**

1. Прежде чем воспользоваться всеми прелестями фреймворка вы должны потратить своё время на то, чтобы узнать, как использовать его.

2. Если задуматься, то термин «готовые к использованию» подразумевает под собой «одно решение для всех», когда фреймворк пытается решить проблемы всех пользователей для каждой ситуации, может случиться так, что разработчик столкнётся с огромным количеством ненужного ему кода.

3. Так как готовые решения сделаны для массового потребителя, вы можете быть почти уверены в том, что вам придётся что-то настраивать под себя для удовлетворения потребностей вашего проекта, что занимает дополнительное время.

4. Во многих случаях, фреймворки не могут покрыть все потребности разработчика, что приводит к дополнительной интеграции сторонних компонентов (например, в виде раздутых плагинов JQuery и т.п.).

5. Практически, вы не имеете никакого контроля над кодом. При этом, если команда разработчиков решит удалить какой-то компонент фреймворка, то вы будете вынуждены признать это изменение. Иначе, если вы не хотите соглашаться с их мнением, придётся модифицировать фреймворк или использовать старую версию их продукта.

Многие фреймворки были созданы для определенных задач и целей, исходя из этого можем сделать вывод, что использование фреймворка это не панацея.
Плохих и хороших фреймворков нет. Для каждой отдельной задачи подходит свое решение и свой фреймворк.

#### 19. Трёхслойная архитектура М.Фаулера.

Фаулер и руководство компании Microsoft по проектированию архитектуры приложений выделяют три слоя абстракции, на которые можно разделить разрабатываемое приложение.

![Fauler](./Fauler.PNG)

**Первый слой абстракции** — это слой доступа к данным. В задачи данного слоя входит абстрагирование от базы данных. SQL-запросы к базе данных, в которой и хранятся данные приложения, скрываются за фасадом, который использует бизнес-слой.

**Второй слой абстракции** — это слой бизнес-логики. Он содержит объекты предметной области, а также функции для работы с ними. Эти функции и реализуют данную бизнес-логику.

**Третий слой абстракции** — это слой взаимодействия с пользователем. Данный слой включает компоненты пользовательского интерфейса.

**Преимущества**:

1. Подход делает возможным параллельную разработку и тестирование каждого из слоев
2. Позволяет изменять структуру или полностью заменять один из слоев не изменяя другие

**Главный недостаток**:

1. Зависимость бизнес-логики от системы хранения

#### 20. Чистая архитектура Р.Мартина.

![xui](./clean_architecture.png)

Clean Architecture объединила в себе идеи нескольких других архитектурных подходов, которые сходятся в том, что архитектура должна:

- быть тестируемой;
- не зависеть от UI;
- не зависеть от БД, внешних фреймворков и библиотек.

Это достигается разделением на слои и следованием Dependency Rule (правилу зависимостей).

**Dependency Rule говорит, что внутренние слои не должны зависеть от внешних.** То есть наша бизнес-логика и логика приложения не должны зависеть от презентеров, UI, баз данных и т.п. На оригинальной схеме это правило изображено стрелками, указывающими внутрь.

_Имена сущностей (классов, функций, переменных, чего угодно), объявленных во внешних слоях, не должны встречаться в коде внутренних слоев._

Это правило позволяет строить системы, которые будет проще поддерживать, потому что изменения во внешних слоях не затронут внутренние слои.

Выделяют 4 слоя:
- **Entities.** Бизнес-логика общая для многих приложений.
- **Use Cases (Interactors).** Логика приложения.
- **Interface Adapters.** Адаптеры между Use Cases и внешним миром. Сюда попадают Presenter’ы из MVP, а также Gateways (репозитории). Преобразовывают данные от use case в формат для внешних агентов и систем хранения (БД, веб, GUI)
- **Frameworks.** Самый внешний слой, тут лежит все остальное: UI, база данных, http-клиент, и т.п.

**Переходы между слоями осуществляются через Boundaries**, то есть через два интерфейса: один для запроса и один для ответа. Они нужны, чтобы внутренний слой не зависел от внешнего (следуя Dependency Rule), но при этом мог передать ему данные.

Через границы данные передаются в скалярном виде или простейшими структурами и объектами – Data Transfer Objects (DTO).

#### 21. Порты и Адаптеры А.Кокберна. Уровни гексагональной архитектуры.

>todo

#### 22. Правило зависимостей и инверсия зависимостей в гексагональной архитектуре.

>todo

#### 23. Типовые решения организации бизнес-логики: сценарий транзакции.

>todo

#### 24. Типовые решения организации бизнес-логики: модель предметной области.

>todo

#### 25. Типовые решения организации бизнес-логики: модуль таблицы.

>todo

#### 26. Слой служб.

>todo

#### 27. Предметно-ориентированное проектирование. Определение, цели, задачи.

>todo

#### 28. Стратегическое проектирование DDD. Концепции.

Domain-Driven Design (Предметно-ориентированное проектирование) - это набор принципов и схем, направленных на создание оптимальных систем объектов.

DDD сводится к созданию программных абстракций, которые называются моделями предметных областей.
В эти модели входит бизнес-логика, устанавливающая связь между реальными условиями области применения продукта и кодом.
Предметно-ориентированное проектирование не является какой-либо конкретной технологией или методологией. DDD — это набор правил, которые позволяют принимать правильные проектные решения. Данный подход позволяет значительно ускорить процесс проектирования программного обеспечения в незнакомой предметной области.

Основная цель DDD: моделировать сложную предметную область так, чтобы программная реализация была простой в случае если:
- Если приложение будет значительно расти и усложняться
- Если предметная область сложна и/или незнакома

DDD основано на:
- Стратегическое проектирование - моделирование предметной области, с разбиением на подобласти, с точки зрения бизнеса, но не технических аспектов,
позволяет поднять уровень знаний (в предметной области) разработчиков и значительно упростить последующую реализацию.
- Тактическое проектирование - применение паттернов и инструментальных средств для моделирования конкретных объектов и их взаимосвязей в рамках
подобластей предметной области.

Концепции DDD:
- Эксперты предметной области - люди, полностью понимающие предметную область бизнеса, для которого строится приложени.
- Модель предметной области - объектная модель предметной области, включающая в себя как поведение, так и данные.
- Подобласти - часть предметной области, отдельная логическая модель некоторой предметной области.
- Единый язык - модель, именованная в терминах предметной области, в четко определенном ограниченном контексте.
- Ограниченный контекст - семантическая контекстная граница; область, в которой реализуется модель.
- Смысловое ядро - ограниченный контекст, который разрабатывается как ключевая стратегическая инциатива; самая важная модель, приносящая конкурентное преимущество.
- Связывание контекстов - это взаимодействие смыслового ядра с другими ограниченными контекстами, любых ограниченных контекстов между собой.
- Карты контекстов - совокупность ограниченных контекстов, а также интеграционных связей между ними.

#### 29. Единый язык и ограниченные контексты.

Единый язык - модель (понятия, объекты, взаимосвязи, процессы), именованная в терминах предметной области, в четко определенном ограниченном контексте.
Это один из основных и самых важных шаблонов предметного-ориентированного проектирования. Это настоящий язык, созданный целостной командой – экспертами в предметной области, разработчиками, бизнес-аналитиками и всеми, кто вовлечен в создание системы. Роль в команде не столь существенна, поскольку каждый член команды использует для описания проекта единый язык. Процесс создания единого языка более творческий чем формальный, так как он, как и любой другой естественный язык, постоянно развивается, а те артефакты, которые вначале способствовали разработке полезного единого языка, со временем устаревают. В итоге, остаются только самые устойчивые и проверенные элементы.
Порой, в нашей профессии, сформулировать требование к продукту бывает сложнее, чем реализовать его. Разные предметные области сложны по своему. Разрабатывая приложения для банка, трейдинга и др. можно столкнутся с кучей непонятных понятий. 
Единый язык — это базовая концепция борьбы со сложностью. Если предметная область итак требует изучения, то не стоит делать вещи еще сложнее и заставлять людей разбираться еще и в вашей модели предметной области. Стоит называть вещи одинаково как в спецификации, так и в коде.

Ограниченный контекст – семантическая контекстная граница; область, в которой реализуется модель. Очень важно понимать, что в рамках предметной области смысл определенного термина или фразы может сильно отличаться. Ограниченный контекст - граница, в пределах которой понятия единого языка имеют вполне конкретное контекстное значение.
В каждом ограниченном контексте существует только один единый язык.
- Ограниченные контексты являются относительно небольшими, меньше чем может показаться на первый взгляд. 
- Ограниченный контекст достаточно велик только для единого языка изолированной предметной области, но не больше.
- Единый значит «вездесущий» или «повсеместный», т. е. язык, на котором говорят члены команды и на котором выражается отдельная модель предметной области, которую разрабатывает команда. 
- Язык является единым только в рамках команды, работающей над проектом в едином ограниченном контексте.
- Попытка применить единый язык в рамках всего предприятия или что хуже, среди нескольких предприятий, закончится провалом.

#### 30. Подобласти. Смысловое ядро.

Подобласть - часть предметной области, отдельная логическая модель некоторой предметной области. Подобласти позволяют быстрее определить разные части предметной области, необходимые для решения конкретной задачи.

Подобласти делятся на 3 типа:
- Смысловое ядро - это подобласть, имеющая первостепенное значение для организации. Со стратегической точки зрения бизнес должен выделяться своим смысловым ядром. Большинство DDD проектов сосредоточены именно на смысловом ядре. Лучшие разработчики и эксперты должны быть задействованы именно в этой подобласти. Большинство инвестиций должны быть направлены именно сюда для достижения преимущества для бизнеса и получения наибольшей прибыли. Эта задача имеет очень высокий приоритет для организации, потому что именно ее решение дает конкурентное преимущество.
- Вспомогательная подобласть - такая подобласть требует специального моделирования ситуаций, для которых не существует готовых решений. Однако такие подобласти не требуют настолько больших инвестиций, как смысловое ядро. Разработку таких ограниченных контекстов можно поручить сторонним организациям, чтобы не перепутать их с областями стратегического назначения и не вложить в них слишком большие средства. Эта подобласть не является самой важной, может быть реализована позже. И все же это важные программные модели, потому что смысловое ядро не может успешно работать без них. 
- Универсальная подобласть -  Этот вид решения можно приобрести готовым, но можно также привлечь к его разработке сторонние организации или даже отдельное подразделение вашей организации, в которую не входят элитные разработчики, которые в основном должны заниматься смысловым ядром и в меньшей степени вспомогательными подобластями. Опасайтесь принять универсальную подобласть за смысловое ядро. Не надо вкладывать в нее крупные инвестиции.

#### 31. Способы связывания контекстов: общее ядро, партнёрство, клиент-поставщик.

>todo

#### 32. Способы связывания контекстов: конформист, предохранительный уровень, службы с открытым протоколом.

>todo

#### 33. Способы связывания контекстов: общедоступный язык, отдельное существование.

>todo

#### 34. Технологические нюансы связывания контекстов.

>todo

#### 35. Сущность. Объект значений. Фабрика.

>todo

#### 36. Сервисы доменные, прикладные, инфраструктурные.

>todo

#### 37. Агрегат. Генерация идентичности. Репозиторий.

>todo

#### 38. Правила агрегатов. Свойства агрегатов.

>todo

#### 39. Доменные события. Надёжность публикации.

>todo

#### 40. Сага. Компенсирующие транзакции.

>todo

#### 41. Хореография и оркестрация саги.

>todo

#### 42. Порождение событий (ES).

>todo

#### 43. Чем плох монолит?

>todo

#### 44. Куб масштабирования систем.

>todo

#### 45. Сервис-ориентированная архитектура и микросервисы.

**Сервис-ориентированная архитектура (SOA)** — модульный подход к разработке программного обеспечения, основанный на использовании распределённых, слабо связанных заменяемых компонентов, оснащённых стандартизированными интерфейсами для взаимодействия по стандартизированным протоколам.

**Микросервисы** - это небольшие модули, разделённые по принципу выполнения одной бизнес-задачи или одного класса задач. Основная цель такого разделения - возможность изменения, отдельно взятого микросервиса, не меняя при этом связанных с ним компонентов. Бизнес-логика приложения разбивается на отдельные части, каждая из которых представляет собой небольшое приложение, выполняющее одну бизнес-задачу (single responsibility). Число таких приложений ничем не ограничено и между собой они общаются, используя API, построенное, например, на основе HTTP.

![SOA vs MA](https://miro.medium.com/max/1500/1*8-uN932TKtSjNwLw3XuoJQ.png)

SOA VS. МИКРОСЕРВИСЫ

SOA
- Межсервисное взаимодействие – умные каналы, сервисная шина предприятия (ESB), тяжеловесные протоколы типа SOAP
- Глобальная модель данных и общая БД
- Типовой сервис – крупное монолитное приложение

МИКРОСЕРВИСЫ
- Межсервисное взаимодействие – примитивные каналы, как брокер сообщений, прямое взаимоедйствие между сервисами по REST или gRPC
- Отдельные модели данных, своя БД у каждого сервиса
- Типовой сервис – небольшой сервис

**SOA** лучше подходит для больших, сложных корпоративных приложений, требующих интеграции со многими другими приложениями. При этом небольшие приложения не очень подходят для SOA, так как им не требуется компонент промежуточного программного обеспечения для обмена сообщениями. 

**Микросервисы** лучше подходят для небольших и хорошо разделенных веб-систем. Если вы разрабатываете мобильное или веб-приложение, то микросервисы дают вам гораздо больший контроль как разработчику. 

#### 46. Достоинства и недостатки микросервисов.

>todo

#### 47. Функциональная декомпозиция на сервисы.

>todo

#### 48. Команды и сервисы: размер, состав и закон Конвея.

>todo

#### 49. Проблемы и выгоды распределённости в микросервисной архитектуре.

>todo

#### 50. Стили взаимодействия микросервисов.

>todo

#### 51. Удалённый вызов процедур: REST.

>todo

#### 52. Удалённый вызов процедур: gRPC.

>todo

#### 53. Удалённый вызов процедур: механизм сообщений.

>todo

#### 54. Проблемы запроса данных из нескольких сервисов. Объединение API.

>todo

#### 55. CQRS. Запрашивающий сервис.

>todo

#### 56. Процесс и стратегии перехода от монолита к микросервисам.

**Стратегий перехода от монолита к микросервисам**

1. **Разбиение монолита путем оформления функциональности в виде сервисов**
   Самая простая из них и почти всегда неправильная — разработать микросервисную архитектуру с нуля, используя монолитное приложение, как пример для подражания. Наверное, распространенность такого подхода и есть главным аргументом приверженцев писать приложения сразу на микросервисах. Но это серьезно добавляет стоимости к изначальной разработке приложения.

2. **Реализация новых возможностей в виде сервисов**
   Более адекватным подходом перехода от монолита к микросервисам является постепенное отпочковывание микросервисов и написание новой функциональности уже отдельно от основного приложения. Подход хороший и рабочий, но имеет один существенный недостаток — основное монолитное приложение в обозримом будущем не исчезнет. В итоге у нас будет монолит и куча вспомогательных сервисов, вместо набора независимых микросервисов.

3. **Разделение уровня представления и внутренних компонентов**
   В конечном счете, вменяемым способом перейти к микросервисной архитектуре можно назвать способ, при котором основное монолитное приложение разбивается на несколько крупнокалиберных приложений с сильной взаимной связностью. После чего подприложения рассматриваются и рефакторятся отдельно, попутно задевая соседей и заставляя их приспосабливаться и изменяться вместе. Постепенно такой подход приведет к уменьшению связности и появлению устоявшегося интерфейса каждого подприложения. При достижении такой вот устоявшейся временной точки, представляется возможным вносить изменения в подприложения, не затрагивая при этом соседние. И это подприложение рассматривается, как монолит попроще и уровнем ниже. И с ним проделываются аналогичные процедуры. Постепенно приложение бьется на более-менее равные части. Некоторые части в процессе становятся ненужными, некоторые дублируют уже существующие другие части или вообще сливаются в один общий сервис для устранения дублирования. В итоге рано, или скорее поздно, получается устоявшееся приложение на микросервисной архитектуре.

#### 57. Определение и история DevOps. Концепции разработки, релиза и развертывания ПО.

>todo

#### 58. Непрерывная сборка и развертывание. Конвейер непрерывного развертывания: автоматизация сборки, тестирование, развертывание, эксплуатация.

>todo

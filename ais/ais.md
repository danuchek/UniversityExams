#### 1. Какие группы функций можно выделить в многозвенной архитектуре сетевых приложений? Какие задачи они призваны решить? Архитектура «клиент-сервер»

1. Функции ввода и отображения данных (обеспечивают взаимодействие с пользователем);
2. Прикладные функции, характерные для данной предметной области;
3. Функции управления ресурсами (файловой системой, базой данных и т.д.).

Выполнение этих функций в основном обеспечивается программными средствами, которые можно представить в виде взаимосвязанных компонентов, где:
- компонент представления отвечает за пользовательский интерфейс;
- прикладной компонент реализует алгоритм решения конкретной задачи;
- компонент управления ресурсом обеспечивает доступ к необходимым ресурсам.

#### 2. Какие основные модели существуют в рамках двухзвенной архитектуры? Как распределяются функции представления, прикладной логики и доступа к ресурсам между клиентом и сервером в рамках каждой модели?

Расположение компонентов на стороне клиента или сервера определяет следующие основные модели их взаимодействия в рамках двухзвенной архитектуры:
- сервер терминалов — распределенное представление данных;
- файл-сервер — доступ к удаленной базе данных и файловым ресурсам;
- сервер БД — удаленное представление данных;
- сервер приложений — удаленное приложение.

#### 3. Какие порты tcp/ip зарезервированы за службой DNS? Какие типы DNS-серверов существуют?

По умолчанию за DNS зарезервирован порт 53 tcp.
 
##### Корневой DNS-сервер

Это DNS-сервер, который хранит в себе адреса всех TLD-серверов (TLD — top-level domain, домен верхнего уровня). По пути от имени хоста до IP-адреса запрос сначала попадает на корневой DNS-сервер.
 
##### TLD-серверы

Эти серверы связаны с доменами верхнего уровня (TLD). Обычно они идут после корневых DNS-серверов. В TLD-серверах содержится информация о домене верхнего уровня конкретного хоста.

##### Авторитативный DNS-сервер

Запрос на эти серверы поступает в самую последнюю очередь. Эти серверы хранят фактические записи типа A, NS, CNAME, TXT, и т.п. Авторитативные DNS-серверы по возможности возвращают IP-адреса хостов. Если сервер этого сделать не может — он выдаёт ошибку, и на этом поиск IP-адреса по серверам заканчивается.

#### 4. Что такое ресурсная запись? Приведите пример 5 типов ресурсных записей и их назначения.

Ресурсная запись - это записи в системе доменных имен о соответствии имени и служебной информации о сервере, на которое это имя должно указывать.
- A – IP адрес IPV4;
- AAAA – IP адрес IPV6;
- NS - Указывает сервер DNS-имен для именованной зоны;
- MX – Указывает почтовые данные;
- TXT – Указывает текстовую информацию. 


#### 5. Что такое домен? Что такое делегирование домена? Зачем оно нужно?

Символьное имя, определенная зона в структуре адресов Интернета.

Делегирование домена — внесение в доменную зону информации о DNS серверах, которые содержат IP-адреса и прочие данные, необходимые для функционирования домена. Проще говоря — это привязка домена к определенному серверу хостинг-провайдера, чтобы сайт открывался в браузере, когда вы указываете нужное доменное имя.
	
#### 6. Как работает рекурсивный запрос? Чем он отличается от итеративного? Должен ли сервер отвечать на рекурсивный запрос?

**Рекурсивный запрос** - это такой метод, при котором DNS сервер просто пересылает данные от клиента другому серверу, что бы он обработал данный запрос и вернул конечные данных.

**Итеративный запрос** – это такой метод, при котором DNS сервер выступает в роли клиента и опрашивает другие DNS сервера в порядке убывания (начиная от корневых DNS серверов и заканчивая последним, авторитарным за нужную DNS зону).

Сервер может отвечать на рекурсивный запрос в зависимости от его настройки.

#### 7. Структура HTTP сообщения. Коды состояний протокола HTTP.

Структура протокола определяет, что каждое HTTP-сообщение состоит из трёх
частей, которые передаются в следующем порядке:
1. Стартовая строка — определяет тип сообщения;
2. Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;
3. Тело сообщения (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

Коды состояний протокола HTTP:
- 1xxx - информационные
- 2ххх - успешные
- 3ххх - перенаправление
- 4ххх - ошибки клиента
- 5ххх - ошибки сервера

#### 8. Методы протокола HTTP. Ответы каких методов не кэшируются? Какие методы безопасны?

Метод HTTP — последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом.

**OPTIONS** - Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса.

**GET** - Используется для запроса содержимого указанного ресурса.

**HEAD** - Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело.

**POST** - Применяется для передачи пользовательских данных заданному ресурсу.

**PUT** - Применяется для загрузки содержимого запроса на указанный в запросе URI.

**PATCH** - Аналогично PUT, но применяется только к фрагменту ресурса.

**DELETE** - Удаляет указанный ресурс.

**TRACE** -  Возвращает полученный запрос так, что клиент может увидеть, что промежуточные сервера добавляют или изменяют в запросе.

**LINK** - Устанавливает связь указанного ресурса с другими.

**UNLINK** - Убирает связь указанного ресурса с другими.

#### 9. Последовательные и конкурентные серверы. Асинхронная событийная модель работы сервера.

**Последовательные**:

Чтение очереди вход. сообщ -> Есть сообщение -> обработка запроса -> отправка ответа;

**Конкурентный**:

Чтение очереди вход. сообщ -> Есть сообщение -> запуск нового сервера для обработки запроса

#### 10. Apache и nginx. Архитектура обработки соединений.

Apache предоставляет несколько модулей мультипроцессинга (multi-processing modules, MPM), которые отвечают за то как запрос клиента будет обработан.

`mpm_prefork` — этот модуль создает по одному процессу с одним потоком на каждый запрос.

`mpm_worker` — этот модуль создает процессы, каждый из которых может управлять несколькими потоками. Каждый поток может обрабтывать одно соединение. Потоки значительно более эффективны чем процессы, что означает что `mpm_worker` масштабируется значительно лучше, чем `mpm_prefork`.

`mpm_event` — этот модуль похож на `mpm_worker`, но оптимизрован под работу с keep-alive соединениями. Когда используется `mpm_worker` соединение будет удерживать поток вне зависимости от того активное это соединение или keep-alive. `mpm_event` выделяет отдельные потоки для keep-alive соединений и отдельные потоки для активных соединений.

Nginx создает процессы-воркеры каждый из которых может обслуживать тысячи соединений. Воркеры достигают такого результата благодаря механизму основанному на быстром цикле, в котором проверяются и обрабатываются события. Каждое соединение, обрабатываемое воркером, помещается в event loop вместе с другими соединениями. В этом цикле события обрабатываются асинхронно, позволяя обрабатывать задачи в неблокирующей манере. Когда соединение закрывается оно удаляется из цикла.


#### 11. Протоколы взаимодействия с web-сервером.

Примером использования набора протоколов в сетевой связи является взаимодействие между веб-сервером и веб-клиентом. Это взаимодействие использует ряд протоколов и стандартов в процессе обмена информацией между ними. Различные протоколы взаимодействуют друг с другом, чтобы гарантировать, что сообщения будут приняты и понятны обеими сторонами. Примерами этих протоколов являются следующие.

Протокол прикладного уровня — протокол передачи гипертекста (HTTP): определяет, каким образом взаимодействуют веб-сервер и веб-клиент. HTTP определяет содержание и формат запросов и ответов, которыми обмениваются клиент и сервер. Программное обеспечение и веб-клиента, и веб-сервера реализует HTTP как часть приложения. Для управления процессом передачи сообщений между клиентом и сервером HTTP обращается к другим протоколам.

Транспортный протокол — протокол управления передачей (TCP): управляет отдельными сеансами связи между серверами и клиентами в Интернете. TCP делит сообщения HTTP на более мелкие части, называемые сегментами. Эти сегменты передаются между веб-сервером и клиентскими процессами, запущенными на узле назначения. TCP также отвечает за управление размером и скоростью, с которой происходит обмен сообщениями между сервером и клиентом.

Интернет-протокол — протокол IP: отвечает за приём форматированных сегментов от TCP, инкапсуляцию их в пакеты, присвоение им соответствующих адресов и их доставку по наилучшему пути к узлу назначения.

Протоколы сетевого доступа: описывают две основные функции — связь по каналу передачи данных и физическую передачу данных по сетевой среде. Протоколы управления каналами передачи данных принимают пакеты от протокола IP и форматируют их для передачи в среде. Стандарты и протоколы физической передачи данных управляют тем, как сигналы посылаются и как они интерпретируются клиентами при получении. Одним из примеров протокола сетевого доступа является Ethernet.


#### 12. Дайте определение понятию «инфраструктура открытого ключа».
**Инфраструктура открытого ключа** (PKI) является системой цифровых сертификатов, центров сертификации (ЦС), которая производит проверку и подтверждение подлинности каждой из сторон, участвующих в электронной операции, с помощью криптографии открытых ключей.

Сертификат открытого ключа, обычно называемый просто сертификатом – это документ с цифровой подписью, связывающий значение открытого ключа с удостоверением пользователя, устройства или службы, которым принадлежит соответствующий закрытый ключ.

#### 13. Дайте определение понятию «электронная цифровая подпись». Как происходит генерация ЭЦП?

Электронная цифровая подпись (ЭЦП) - реквизит электронного документа, предназначенный для удостоверения источника данных и защиты данного электронного документа от подделки.

Схема электронной подписи обычно включает в себя:
* алгоритм генерации ключей пользователя;
* функцию вычисления подписи;
* функцию проверки подписи.

Функция вычисления подписи на основе документа и секретного ключа пользователя вычисляет собственно подпись. Функция проверки подписи проверяет, соответствует ли данная подпись данному документу и открытому ключу пользователя.

Открытый ключ пользователя доступен всем, так что любой может проверить подпись под данным документом.

Для того что бы подписать документ нужно зашифровать с помощью закрытого ключа значение хеш-функции от содержимого документа. Чтобы проверить подпись, нужно расшифровать с помощью открытого ключа значение подписи и убедиться, что оно равно хешу подписанного документа. Таким образом цифровая подпись, это зашифрованный хеш документа.

#### 14. Какие функции лежат на клиенте и на центре сертификации?

Центр Сертификации (Certification Authority, CA) является пакетом программного обеспечения, принимающим и обрабатывающим запросы на выдачу сертификатов, издающим сертификаты и управляющим выданными сертификатами.

#### 15. Может ли центр сертификации отозвать выданный клиенту ключ? Каким образом?

Центр может отзывать сертификат, выданный клиенту, помещая его в черный список, который регулярно передается пользователям центра. С помощью корневого сертификата, который публично доступен, пользователи могут проверять сертификаты друг друга.

#### 16. Дайте определение понятиям схемы, записи, объектного класса и атрибута LDAP.

**Схема LDAP** — описание классов объектов каталога LDAP и их атрибутов. Представляет собой текстовый файл, описывающий типы допустимых и обязательных атрибутов объекта каждого класса.

**Запись** представляет собой набор атрибутов под описательным именем.

**Объектные классы** являются, по существу, контейнерами атрибутов. У каждого объектного класса есть уникальное имя.

**Атрибут** - пара ключ значение.

#### 17. Может ли запись содержать несколько структурных объектных классов? Почему?

Записи должны содержать один и только один структурный объектный класс. У структурного объектного класса может быть вышестоящий объектный класс, тоже являющийся структурным. То есть структурный объектный класс может быть частью иерархии и такая иерархия может быть представлена как единый структурный объектный класс.

#### 18. Какими характеристиками обладает объектный класс?

Объектные классы определяются внутри наборов схемы. Объектные классы могут быть организованы в иерархию, в этом случае они наследуют все свойства своих родительских или вышестоящих (SUP) объектных классов.

Объектные классы могут быть структурными (STRUCTURAL), в этом случае они могут использоваться для создания записей (объектов данных), вспомогательными (AUXILIARY), в этом случае они могут быть добавлены в любую подходящую запись, или абстрактными (ABSTRACT)  — несуществующая "фенечка". Чаще всего встречается абстрактный объектный класс top, формирующий самый верхний уровень любой иерархии объектных классов и ограничивающий любую иерархию.

Если объектный класс является частью иерархии, он должен быть того же типа (структурный, вспомогательный), что и любой из вышестоящих объектных классов. Исключение из этого правила — случай, когда вышестоящий объектный класс — это top (абстрактного типа), служащий, как уже отмечалось, для ограничения любой иерархии.

Объектные классы предназначены для подключения атрибутов (на жаргоне это называется контейнерами атрибутов).

Объектные классы определяют, является ли атрибут обязательным (MUST), то есть должен присутствовать в записи, либо необязательным (MAY), то есть может присутствовать в записи с данным объектным классом.

#### 19. Какими характеристиками обладает атрибут?

Каждый атрибут определён в наборе схемы данных.

Каждый атрибут входит в один или несколько объектных классов.

objectclass также является атрибутом и может использоваться в операциях поиска.

Чтобы использовать атрибут в записи, в определение этой записи должен быть включен его объектный класс и этот объектный класс должен быть включен в набор схемы данных. В свою очередь, этот набор схемы должен быть известен LDAP-серверу.

Характеристики атрибута определяются с помощью нотации ASN.1.

Атрибут может появляться лишь однажды в любом экземпляре содержащего его объектного класса (SINGLE-VALUE), либо может появляться более одного раза в любом экземпляре содержащего его объектного класса (MULTI-VALUE). Значение по умолчанию — MULTI-VALUE.

Определение атрибута может быть частью иерархии, в этом случае оно наследует все свойства своих родителей. Например, commonName (cn), givenName (gn), surname (sn) являются потомками атрибута name.

Определение атрибута включает его тип или синтаксис (SYNTAX), например, строка или число, а также как он будет вести себя в определённых условиях; например, будет ли при операциях сравнения учитываться регистр символов или нет.

Атрибуты, поддерживаемые сервером LDAP, формируют коллекцию под названием attributetypes, просмотреть которую можно через subschema.

#### 20. Основные понятия AAA. Идентификация, аутентификация, авторизация.

Идентификация – сервис, с помощью которого определяются уникальные свойства пользователей, с помощью которых можно отличать их друг от друга, и способы, с помощью которых, пользователи указывают свои идентификации информационной системе. 

Аутентификация – сервис, с помощью которого доказывается, что участники являются требуемыми, т.е. обеспечивается доказательство идентификации. Это может достигаться с помощью паролей, смарт-карт, биометрических токенов и т.п.

Авторизация - выдача прав доступа к функционалу.

#### 21. Протокол RADIUS. Модель взаимодействие точки доступа и ААА-сервера.

Сервер RADIUS – сервер, выполняющий аутентификацию, авторизацию и хранение учетных записей
(аккаунтинг). В английском варианте Authentication, Authorization и Accounting – ААА. RADIUS предоставляет
сервисы ААА для NAS(Network Access Server).

**Модель взаимодействия**

![model](https://sun9-65.userapi.com/c855320/v855320318/20c0f8/c4vt3cVyBLQ.jpg)

1. Абонент подключается к устройству доступа AGW (Access Gateway) или
Network Access Server (NAS) и вводит свой логин и пароль.
2. AGW (NAS) формирует и посылает запрос аутентификации к AAA-серверу и
ожидает ответ.
3. AAA-сервер обращается к DPI-системе или серверу биллинга по протоколу
RADIUS для проверки логина абонента и пароля.
4. AAA-сервер формирует ответ и отсылает его обратно на AGW (NAS).
5. Если аутентификация пройдена, то AGW (NAS) пропускает абонента в сеть, но
пока еще не предоставляет ему никаких услуг.
6. Если пользователь пытается выйти в Интернет (вводит URL в строке
браузера), AGW (NAS) формирует новый запрос AAA-серверу для авторизации.
7. ААА-сервер вновь обращается к DPI-системе или серверу биллинга, чтобы
получить информацию о тарифном плане и подключенных абоненту услугах.
8. Получив положительный ответ от биллинга, ААА-сервер посылает ответ на
AGW (NAS), и абонент получает доступ к Интернету в соответствии с
настройками, установленными для тарифного плана.

#### 22. Протокол Kerberos. Модель взаимодействия принципалов и центра распределения ключей.

Централизованное распределение ключей симметричного шифрования подразумевает, что у каждого абонента сети есть только один основной ключ, который используется для взаимодействия с центром распределения ключей (сервером ключей). Чтобы получить ключ шифрования для защиты обмена данными с другим абонентом, пользователь обращается к серверу ключей, который назначает этому пользователю и соответствующему абоненту сеансовый симметричный ключ.
Протокол Kerberos обеспечивает распределение ключей симметричного шифрования и проверку подлинности пользователей, работающих в незащищенной сети. Реализация Kerberos - это программная система, построенная по архитектуре "клиент-сервер". Клиентская часть устанавливается на все компьютеры защищаемой сети, кроме тех, на которые устанавливаются компоненты сервера Kerberos. В роли клиентов Kerberos могут, в частности, выступать и сетевые серверы (файловые серверы, серверы печати и т.д.).

Серверная часть Kerberos называется центром распределения ключей и состоит из двух компонент:
 - сервер аутентификации;
 - сервер выдачи разрешений.
Каждому субъекту сети сервер Kerberos назначает разделяемый с ним ключ симметричного шифрования и поддерживает базу данных субъектов и их секретных ключей.

Пусть клиент C собирается начать взаимодействие с сервером SS. В несколько упрощенном виде, протокол предполагает следующие шаги:
1. C->AS: {c}.
Клиент C посылает серверу аутентификации AS свой идентификатор c (идентификатор передается открытым текстом).
2. AS->C: {{TGT}K(AS_TGS), K(C_TGS)} K(C),
На этом шаге сервер аутентификации AS, проверив, что клиент C имеется в его базе, возвращает ему билет для доступа к серверу выдачи разрешений и
ключ для взаимодействия с сервером выдачи разрешений. Вся посылка зашифрована на ключе клиента C.
3. C->TGS: {TGT}K(AS_TGS), {Aut1}K(C_TGS), {ID}
Клиент C на этот раз обращается к серверу выдачи разрешений ТGS. Он пересылает полученный от AS билет, зашифрованный на ключе K(AS_TGS), и
аутентификационный блок, содержащий идентификатор c и метку времени, показывающую, когда была сформирована посылка.Сервер выдачи
разрешений расшифровывает билет TGT и получает из него информацию о том, кому был выдан билет, когда и на какой срок, ключ шифрования,
сгенерированный сервером AS для взаимодействия между клиентом C и сервером TGS. С помощью этого ключа расшифровывается аутентификационный блок. Если метка в блоке совпадает с меткой в билете, это доказывает, что посылку сгенерировал на самом деле С. Далее делается проверка времени действия билета и времени отправления посылки 3. Если проверка проходит и действующая в системе политика позволяет клиенту С обращаться к клиенту SS, тогда выполняется шаг 4.
4. TGS->C: {{TGS}K(TGS_SS),K(C_SS)} K(C_TGS),
Сейчас сервер выдачи разрешений TGS посылает клиенту C ключ шифрования и билет, необходимые для доступа к серверу SS.
Структура билета такая же, как на шаге 2:
 - идентификатор того, кому выдали билет;
 - идентификатор того, для кого выдали билет;
 - отметка времени;
 - период действия;
 - ключ шифрования.
5. C->SS: {TGS}K(TGS_SS), {Aut2}K(C_SS)
Клиент C посылает билет, полученный от сервера выдачи разрешений, и свой аутентификационный блок серверу SS, с которым хочет установить сеанс
защищенного взаимодействия. Предполагается, что SS уже зарегистрировался в системе и распределил с сервером TGS ключ шифрования K(TGS_SS). Имея этот ключ, он может расшифровать билет, получить ключ шифрования K(C_SS) и проверить подлинность отправителя сообщения.
6. SS->C: {t4 + 1}K(C_SS)
Nеперь уже SS должен доказать C свою подлинность. Он может сделать это, показав, что правильно расшифровал предыдущее сообщение. Вот поэтому, SS берет отметку времени из аутентификационного блока C, изменяет ее заранее определенным образом (увеличивает на 1), шифрует на ключе K(C_SS) и возвращает C.

#### 23. Для чего используется протоколы SMTP и POP3? Какие порты TCP/IP закреплены за данными протоколами?	

Основная задача протокола SMTP (Simple Mail Transfer Protocol) заключается в том, чтобы обеспечивать передачу электронных сообщений (почту).

РОР3 – позволяет только забрать почту из почтового ящика сервера на рабочую станцию клиента и удалить ее из почтового ящика на сервере. SMTP порт 25, POP3 порт 110.

#### 24. Опишите схему взаимодействия между клиентом и сервером по протоколу SMTP.

SMTP (Simple Mail Transfer Protocol) — это сетевой протокол, предназначенный для передачи электронной почты в сетях TCP/IP. SMTP обычно используется для транспортировки через интернет исходящих сообщений к конкретному месту назначения. Протокол проверяет конфигурацию сообщения, отправляет его, после чего отслеживает результат, чтобы убедиться в успешности доставки. Если email-сообщение не может быть доставлено, об этом сообщается отправителю.

Взаимодействие в рамках SMTP строится по принципу двусторонней связи, которая устанавливается между отправителем и получателем почтового сообщения. При этом отправитель инициирует соединение и посылает запросы на обслуживание, а получатель - отвечает на эти запросы. Фактически, отправитель выступает в роли клиента, а получатель - сервера.

![schema](./smtp%20schema.png)

Канал связи устанавливается непосредственно между отправителем и получателем сообщения. При таком взаимодействии почта достигает абонента в течении нескольких секунд после отправки.

#### 25. Опишите схему взаимодействия между клиентом и сервером по протоколу POP3.

Перед работой через протокол POP3 сервер прослушивает порт 110. Когда клиент хочет использовать этот протокол, он должен создать TCP соединение с сервером.
Когда соединение установлено, сервер отправляет приглашение. Затем клиент и POP3 сервер обмениваются информацией пока соединение не будет закрыто или прервано.
POP3 сессия состоит из нескольких режимов:
- AUTHORIZATION (Авторизация) - режим, который устанавливается как только соединение с сервером
было установлено и сервер отправил приглашение. В этом режиме клиент должен идентифицировать
себя на сервере. После успешной идентификации сессия переходит в режим
- TRANSACTION (Передача) - режим, который устанавливается после успешной идентификации. В этом режиме клиент запрашивает сервер выполнить
определённые команды.
- UPDATE (Обновление) - режим, который устанавливается, когда клиент отправляет команду QUIT. В этом режиме POP3 сервер освобождает все занятые ресурсы и
завершает работу. После этого TCP соединение закрывается.

#### 26. Опишите структуру почтового сообщения. Какие заголовки являются обязательными?

Сообщение электронной почты обычно состоит из двух частей:
 
- заголовка (header), содержащего служебную информацию, управляющую доставкой и обработкой сообщения;
- тела (body), содержащего непосредственно пользовательское сообщение: текст и прикрепленные данные (графические, звуковые файлы и т.п.).

**Заголовки:**
- "From:" - отправитель;
- "Reply-To:" - адрес, на который следует отправлять ответ на письмо. Если этот заголовок отсутствует, ответ отправляется на адрес, указанный в заголовке "From:";
- "To:" - основной получатель (получатели);
- "Cc:" - дополнительный получатель (получатели), если необходимы. При доставке письма для адресов в заголовках "To:" и "Cc:" выполняются одинаковые действия; различия между "To:" и "Cc:" в техническом плане нет.
- "Bcc:" - получатель (получатели), невидимый для остальных получателей, если требуется;
- "Subject:" - тема письма (может отсутствовать);
- "Date:" - время отправки письма;
- "Message-ID:" - уникальный идентификатор сообщения, генерируемый MTA-отправителем;
- "Received:" - добавляется каждым транспортным агентом, через которого проходитсообщение, содержит информацию кем, от кого, когда и каким образом получено сообщение.


#### 27. Как отделяется заголовки от текста сообщения? Как завершается ввод сообщения и сервер переходит в командный режим?

Текст отделяется пустой строкой, завершается ввод пустой строкой и точкой.
